[{"categories":["mysql"],"content":"手上是两台新安装的服务器，系统为CentOS7，mysql的版本为5.7，登录的用户为root ","date":"2021-01-19","objectID":"/deploymysql/:0:0","tags":["mysql"],"title":"部署mysql（GTID主从复制）","uri":"/deploymysql/"},{"categories":["mysql"],"content":"1. 改源 把安装的源地址改成阿里云的 shell\u003e cd /etc/yum.repos.d shell\u003e mv CentOS-Base.repo CentOS-Base.repo.back # 备份 shell\u003e wget -O CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo shell\u003e yum clean all shell\u003e yum makecache ","date":"2021-01-19","objectID":"/deploymysql/:1:0","tags":["mysql"],"title":"部署mysql（GTID主从复制）","uri":"/deploymysql/"},{"categories":["mysql"],"content":"2. 安装 获取mysql的源库，也可以到mysql官网查找其他版本 # 基于el7系统 shell\u003e wget https://repo.mysql.com//mysql57-community-release-el7-11.noarch.rpm 安装源库 shell\u003e rpm -Uvh mysql57-community-release-el7-11.noarch.rpm 如果之前安装过的话会提示错误 警告：mysql57-community-release-el7-11.noarch.rpm: 头V3 DSA/SHA1 Signature, 密钥 ID 5072e1f5: NOKEY 错误：依赖检测失败： mysql57-community-release 与 (已安裝) mysql80-community-release-el7-3.noarch 冲突 解决方法，或者直接使用这个命令安装源库 shell\u003e yum install mysql57-community-release-el7-11.noarch.rpm 安装mysql yum install mysql-community-server 提示错误，由于mariadb引起的 错误：软件包：akonadi-mysql-1.9.2-4.el7.x86_64 (@anaconda) 需要：mariadb-server 正在删除: 1:mariadb-server-5.5.64-1.el7.x86_64 (@anaconda) mariadb-server = 1:5.5.64-1.el7 取代，由: mysql-community-server-5.7.33-1.el7.x86_64 (mysql57-community) 未找到 更新，由: 1:mariadb-server-5.5.68-1.el7.x86_64 (base) mariadb-server = 1:5.5.68-1.el7 删除本机上的MariaDB，如果有的话： shell\u003e yum list installed mariadb\\* mariadb.x86_64 mariadb-libs.x86_64 mariadb-server.x86_64 shell\u003e yum remove mariadb.x86_64 mariadb-libs.x86_64 mariadb-server.x86_64 # 重新安装即可 shell\u003e yum install mysql-community-server ","date":"2021-01-19","objectID":"/deploymysql/:2:0","tags":["mysql"],"title":"部署mysql（GTID主从复制）","uri":"/deploymysql/"},{"categories":["mysql"],"content":"3. 启动 启动mysql服务器 shell\u003e service mysqld start 查看一下服务的状态 shell\u003e service mysqld status ● mysqld.service - MySQL Server Active: active (running) 首次启动服务，会进行如下操作 服务器初始化 在数据目录里生成SSL证书和密钥文件 已安装并启用validate_password 创建了一个超级用户帐户'root'@'localhost'。生成了一个随机密码，使用如下命令进入日志文件中能查看： shell\u003e grep 'temporary password' /var/log/mysqld.log 使用密码登录root帐户 shell\u003e mysql -u root -p 记得修改密码 mysql\u003e ALTER USER 'root'@'localhost' IDENTIFIED BY 'MyNewPassword'; 另外：其中一台服务器启动时报错： Unable to determine if daemon is running: No such file or directory 使用如下命令解决： shell\u003e service mysqld stop shell\u003e rm -rf /var/lib/mysql/* shell\u003e service mysqld start 安装完后可以使用以下命令做一些安全设置 shell\u003e mysql_secure_installation Change the password for root ? # 上面已经改了这里不再修改 直接回车下一步 Remove anonymous users? # y Disallow root login remotely? # y Remove test database and access to it? # y Reload privilege tables now? # y ","date":"2021-01-19","objectID":"/deploymysql/:3:0","tags":["mysql"],"title":"部署mysql（GTID主从复制）","uri":"/deploymysql/"},{"categories":["mysql"],"content":"4. 复制 使用全局事务标识符（GTID）复制 数据库每提交一个事务，都会生成一个标识符，并记录在binlog中，该标识符在源数据库上唯一，且下面所有副本服务器中也是唯一。代替了基于binlog复制的file和pos。但需要在副本数据库中开启binlog，这有意味着在切换新源或启用新副本时不必引用源的binlog，容易保证数据的一致性。如果副本不开启binlog则会存储在tablemysql.gtid_executed里。 注意：必须在源服务器上启用binlog才能进行复制 ","date":"2021-01-19","objectID":"/deploymysql/:4:0","tags":["mysql"],"title":"部署mysql（GTID主从复制）","uri":"/deploymysql/"},{"categories":["mysql"],"content":"4.1 设置配置 关闭mysql数据库： shell\u003e mysqladmin -u root -p shutdown 设置配置，配置文件在/etc/my.conf。或者使用以下命令查找： shell\u003e mysql --verbose --help | grep my.cnf 增加配置： [mysqld] log-bin=mysql-bin # 启用二进制日志文件 server-id=1 # 设置服务唯一id，副本服务器为2 gtid_mode=ON # 启用基于GTID的复制 enforce-gtid-consistency=ON # 启用GTID模式 启动数据库 ","date":"2021-01-19","objectID":"/deploymysql/:4:1","tags":["mysql"],"title":"部署mysql（GTID主从复制）","uri":"/deploymysql/"},{"categories":["mysql"],"content":"4.2 创建副本用户 在源上创建一个新的帐号，用于给所有的副本连接，并提供复制的权限。 mysql\u003e CREATE USER 'repl'@'192.168.7.%' IDENTIFIED BY 'password'; mysql\u003e GRANT REPLICATION SLAVE ON *.* TO 'repl'@'192.168.7.%'; ","date":"2021-01-19","objectID":"/deploymysql/:4:2","tags":["mysql"],"title":"部署mysql（GTID主从复制）","uri":"/deploymysql/"},{"categories":["mysql"],"content":"4.3 配置副本为GTID自动定位 配置副本使用GTID的事务的源来更新数据，并使用GTID定位。 mysql\u003e CHANGE MASTER TO -\u003e MASTER_HOST = '192.168.7.30', -\u003e MASTER_PORT = 3306, -\u003e MASTER_USER = 'repl', -\u003e MASTER_PASSWORD = 'password', -\u003e MASTER_AUTO_POSITION = 1; 启动副本： mysql\u003e START SLAVE; ","date":"2021-01-19","objectID":"/deploymysql/:4:3","tags":["mysql"],"title":"部署mysql（GTID主从复制）","uri":"/deploymysql/"},{"categories":["mysql"],"content":"4.4 （可选）设置防火墙 如果开启了防火墙则需要开放3306端口： shell\u003e firewall-cmd --zone=public --add-port=3306/tcp --permanent shell\u003e firewall-cmd --reload ","date":"2021-01-19","objectID":"/deploymysql/:4:4","tags":["mysql"],"title":"部署mysql（GTID主从复制）","uri":"/deploymysql/"},{"categories":["golang"],"content":"struct可以比较，但有一些条件需要注意 ","date":"2021-01-13","objectID":"/comparearrayandslice/:0:0","tags":["golang","struct"],"title":"golang的struct比较","uri":"/comparearrayandslice/"},{"categories":["golang"],"content":"相同类型 必须是相同类型的struct type A struct { Num int } type B struct { Num int } a := A{} b := B{} fmt.Println(a==b) 不同类型的struct比较的话会编译不通过：invalid operation: a == b (mismatched types A and B) ","date":"2021-01-13","objectID":"/comparearrayandslice/:1:0","tags":["golang","struct"],"title":"golang的struct比较","uri":"/comparearrayandslice/"},{"categories":["golang"],"content":"不可比较的类型 当strct里有一下3种类型时，则不可比较 map func slice type A struct { M map[int]int } a := A{} b := A{} fmt.Println(a==b) 以上代码编译时会报错：invalid operation: a == b (struct containing map[int]int cannot be compared) 可以到源码里找到相应的代码 /cmd/compile/internal/gc/typecheck.go func typecheck1() // 检查类型 func IncomparableField() // 返回结构体不可比较的字段，如果有的话 func IsComparable() // 判断字段的类型是否可以比较 func algtype1() // 判断类型是否可比较 ... // 类型不可比较时返回 // 每个类型都有一个flags属性，该属性包含了Noalg判断是否可以比较 // slice在初始化的时候会SetNoalg(true) // map在创建hmap时会SetNoalg(true) // func在创建匿名函数也会SetNoalg(true) if t.Noalg() { return ANOEQ, t } // 以防万一下面还会有一次判断 switch t.Etype { // func和map case TFUNC, TMAP: return ANOEQ, t // slice case TSLICE: return ANOEQ, t } 同理我们平时比较的时候，也不能用以上3种去比较 另外，若struct包含array或struct，那么array和struct也不能有以上3种类型 ","date":"2021-01-13","objectID":"/comparearrayandslice/:2:0","tags":["golang","struct"],"title":"golang的struct比较","uri":"/comparearrayandslice/"},{"categories":null,"content":"Hello World This is my first post. ","date":"2020-12-31","objectID":"/first/:0:0","tags":null,"title":"Hello World","uri":"/first/"}]