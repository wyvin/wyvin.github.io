[{"categories":["mysql"],"content":" 数据库有一张专门记录设备数据变化的表，目前已经有150W+条记录了，每次使用group by语句时用时都比较长，甚至出现i/o timeout执行超时，需要优化一下 表结构大概如下 +--------------+---------------------+------+-----+---------------------+----------------+ | Field | Type | Null | Key | Default | Extra | +--------------+---------------------+------+-----+---------------------+----------------+ | id | bigint(20) unsigned | NO | PRI | NULL | auto_increment | | device_id | varchar(64) | NO | MUL | | | | reading_type | int(11) | NO | MUL | 1 | | | reading | varchar(64) | NO | | 0 | | | action_time | varchar(64) | NO | MUL | 1970-01-01 00:00:00 | | +--------------+---------------------+------+-----+---------------------+----------------+ 要求： 需要找出某个device_id的每个reading_type的最新一条记录 ","date":"2021-03-29","objectID":"/optimizegroupby/:0:0","tags":["mysql"],"title":"优化GroupBy语句","uri":"/optimizegroupby/"},{"categories":["mysql"],"content":"优化前 原来的sql： SELECT a.* FROM device_amount_record a, ( SELECT MAX( id ) AS id FROM device_amount_record WHERE device_id =? GROUP BY reading_type ) b WHERE a.id = b.id 执行时间基本超过了5s，而数据库的超时配置为5s，所以经常报错。 使用explain分析下： +----+-------------+----------------------+------------+--------+--------------------+---------+---------+-------+--------+----------+--------------------------------------------------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+----------------------+------------+--------+--------------------+---------+---------+-------+--------+----------+--------------------------------------------------------+ | 1 | PRIMARY | \u003cderived2\u003e | NULL | ALL | NULL | NULL | NULL | NULL | 474474 | 100.00 | Using where | | 1 | PRIMARY | a | NULL | eq_ref | PRIMARY | PRIMARY | 8 | b.id | 1 | 100.00 | NULL | | 2 | DERIVED | device_amount_record | NULL | ref | devID,reading_type | devID | 258 | const | 474474 | 100.00 | Using index condition; Using temporary; Using filesort | +----+-------------+----------------------+------------+--------+--------------------+---------+---------+-------+--------+----------+--------------------------------------------------------+ 可以看到Extra列中的值有：Using temporary和Using filesort Using temporary 表示使用了临时表，创建一个临时表比较耗时和耗内存。推测是语句中的b表或inner join时使用了临时表。 使用show global status like '%tmp%';命令查看发现临时表是建在硬盘上的，推测临时表超过了mysql设置的最大内存。。 Using filesort 表示没有使用索引的排序。 ","date":"2021-03-29","objectID":"/optimizegroupby/:1:0","tags":["mysql"],"title":"优化GroupBy语句","uri":"/optimizegroupby/"},{"categories":["mysql"],"content":"优化后 由于id使用了自增，所以可以通过查找最大的id来找到最新的数据。因为需要根据action_time做业务，这里还是根据action_time排序。 由于group by扫描的行数太多，而我们其实可以知道有哪些reading_type的，所以优化的思路就是提供reading_type过滤，减少扫描。 修改后的sql： SELECT * FROM ( SELECT reading_type, reading, action_time FROM device_amount_record WHERE device_id = ? AND reading_type = ? ORDER BY action_time DESC LIMIT 1 ) a UNION SELECT * FROM ( SELECT reading_type, reading, action_time FROM device_amount_record WHERE device_id = ? AND reading_type = ? ORDER BY action_time DESC LIMIT 1 ) b ... 每一个reading_type写一条sql，然后用union连接起来。 单条的sql使用索引device_id,reading_type搜索，使用索引action_time排序，由于业务原reading_type的数量一般不多，union建立的临时表很小。 优化后执行时间只有0.01s~! ","date":"2021-03-29","objectID":"/optimizegroupby/:2:0","tags":["mysql"],"title":"优化GroupBy语句","uri":"/optimizegroupby/"},{"categories":["mysql"],"content":"手上是两台新安装的服务器，系统为CentOS7，mysql的版本为5.7，登录的用户为root ","date":"2021-01-19","objectID":"/deploymysql/:0:0","tags":["mysql"],"title":"部署mysql（GTID主从复制）","uri":"/deploymysql/"},{"categories":["mysql"],"content":"1. 改源 把安装的源地址改成阿里云的 shell\u003e cd /etc/yum.repos.d shell\u003e mv CentOS-Base.repo CentOS-Base.repo.back # 备份 shell\u003e wget -O CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo shell\u003e yum clean all shell\u003e yum makecache ","date":"2021-01-19","objectID":"/deploymysql/:1:0","tags":["mysql"],"title":"部署mysql（GTID主从复制）","uri":"/deploymysql/"},{"categories":["mysql"],"content":"2. 安装 获取mysql的源库，也可以到mysql官网查找其他版本 # 基于el7系统 shell\u003e wget https://repo.mysql.com//mysql57-community-release-el7-11.noarch.rpm 安装源库 shell\u003e rpm -Uvh mysql57-community-release-el7-11.noarch.rpm 如果之前安装过的话会提示错误 警告：mysql57-community-release-el7-11.noarch.rpm: 头V3 DSA/SHA1 Signature, 密钥 ID 5072e1f5: NOKEY 错误：依赖检测失败： mysql57-community-release 与 (已安裝) mysql80-community-release-el7-3.noarch 冲突 解决方法，或者直接使用这个命令安装源库 shell\u003e yum install mysql57-community-release-el7-11.noarch.rpm 安装mysql yum install mysql-community-server 提示错误，由于mariadb引起的 错误：软件包：akonadi-mysql-1.9.2-4.el7.x86_64 (@anaconda) 需要：mariadb-server 正在删除: 1:mariadb-server-5.5.64-1.el7.x86_64 (@anaconda) mariadb-server = 1:5.5.64-1.el7 取代，由: mysql-community-server-5.7.33-1.el7.x86_64 (mysql57-community) 未找到 更新，由: 1:mariadb-server-5.5.68-1.el7.x86_64 (base) mariadb-server = 1:5.5.68-1.el7 删除本机上的MariaDB，如果有的话： shell\u003e yum list installed mariadb\\* mariadb.x86_64 mariadb-libs.x86_64 mariadb-server.x86_64 shell\u003e yum remove mariadb.x86_64 mariadb-libs.x86_64 mariadb-server.x86_64 # 重新安装即可 shell\u003e yum install mysql-community-server ","date":"2021-01-19","objectID":"/deploymysql/:2:0","tags":["mysql"],"title":"部署mysql（GTID主从复制）","uri":"/deploymysql/"},{"categories":["mysql"],"content":"3. 启动 启动mysql服务器 shell\u003e service mysqld start 查看一下服务的状态 shell\u003e service mysqld status ● mysqld.service - MySQL Server Active: active (running) 首次启动服务，会进行如下操作 服务器初始化 在数据目录里生成SSL证书和密钥文件 已安装并启用validate_password 创建了一个超级用户帐户'root'@'localhost'。生成了一个随机密码，使用如下命令进入日志文件中能查看： shell\u003e grep 'temporary password' /var/log/mysqld.log 使用密码登录root帐户 shell\u003e mysql -u root -p 记得修改密码 mysql\u003e ALTER USER 'root'@'localhost' IDENTIFIED BY 'MyNewPassword'; 另外：其中一台服务器启动时报错： Unable to determine if daemon is running: No such file or directory 使用如下命令解决： shell\u003e service mysqld stop shell\u003e rm -rf /var/lib/mysql/* shell\u003e service mysqld start 安装完后可以使用以下命令做一些安全设置 shell\u003e mysql_secure_installation Change the password for root ? # 上面已经改了这里不再修改 直接回车下一步 Remove anonymous users? # y Disallow root login remotely? # y Remove test database and access to it? # y Reload privilege tables now? # y ","date":"2021-01-19","objectID":"/deploymysql/:3:0","tags":["mysql"],"title":"部署mysql（GTID主从复制）","uri":"/deploymysql/"},{"categories":["mysql"],"content":"4. 复制 使用全局事务标识符（GTID）复制 数据库每提交一个事务，都会生成一个标识符，并记录在binlog中，该标识符在源数据库上唯一，且下面所有副本服务器中也是唯一。代替了基于binlog复制的file和pos。但需要在副本数据库中开启binlog，这有意味着在切换新源或启用新副本时不必引用源的binlog，容易保证数据的一致性。如果副本不开启binlog则会存储在tablemysql.gtid_executed里。 注意：必须在源服务器上启用binlog才能进行复制 ","date":"2021-01-19","objectID":"/deploymysql/:4:0","tags":["mysql"],"title":"部署mysql（GTID主从复制）","uri":"/deploymysql/"},{"categories":["mysql"],"content":"4.1 设置配置 关闭mysql数据库： shell\u003e mysqladmin -u root -p shutdown 设置配置，配置文件在/etc/my.conf。或者使用以下命令查找： shell\u003e mysql --verbose --help | grep my.cnf 增加源配置： [mysqld] log-bin=mysql-bin # 启用二进制日志文件 必须 server-id=1 # 设置服务唯一id gtid_mode=ON # 启用基于GTID的复制 enforce-gtid-consistency=ON # 启用GTID模式 副本的配置如下： [mysqld] server-id=2 gtid_mode=ON enforce-gtid-consistency=ON # 启用日志（可选） # 启用日志可以在binlog中查找gtid和对应的语句 # 不启用则需要在mysql.gtid_executed表中查找gtid，然后到源上查找对应到语句 # binlog与gtid_executed只生效其中一个 log-bin=mysql-bin log-slave-updates=ON 启动数据库 ","date":"2021-01-19","objectID":"/deploymysql/:4:1","tags":["mysql"],"title":"部署mysql（GTID主从复制）","uri":"/deploymysql/"},{"categories":["mysql"],"content":"4.2 创建副本用户 在源上创建一个新的帐号，用于给所有的副本连接，并提供复制的权限。 mysql\u003e CREATE USER 'repl'@'192.168.7.%' IDENTIFIED BY 'password'; mysql\u003e GRANT REPLICATION SLAVE ON *.* TO 'repl'@'192.168.7.%'; ","date":"2021-01-19","objectID":"/deploymysql/:4:2","tags":["mysql"],"title":"部署mysql（GTID主从复制）","uri":"/deploymysql/"},{"categories":["mysql"],"content":"4.3 配置副本为GTID自动定位 配置副本使用GTID的事务的源来更新数据，并使用GTID定位。 mysql\u003e CHANGE MASTER TO -\u003e MASTER_HOST = '192.168.7.30', -\u003e MASTER_PORT = 3306, -\u003e MASTER_USER = 'repl', -\u003e MASTER_PASSWORD = 'password', -\u003e MASTER_AUTO_POSITION = 1; 启动副本： mysql\u003e START SLAVE; ","date":"2021-01-19","objectID":"/deploymysql/:4:3","tags":["mysql"],"title":"部署mysql（GTID主从复制）","uri":"/deploymysql/"},{"categories":["mysql"],"content":"4.4 （可选）设置防火墙 如果开启了防火墙则需要开放3306端口： shell\u003e firewall-cmd --zone=public --add-port=3306/tcp --permanent shell\u003e firewall-cmd --reload ","date":"2021-01-19","objectID":"/deploymysql/:4:4","tags":["mysql"],"title":"部署mysql（GTID主从复制）","uri":"/deploymysql/"},{"categories":["golang"],"content":"struct可以比较，但有一些条件需要注意 ","date":"2021-01-13","objectID":"/comparearrayandslice/:0:0","tags":["golang","struct"],"title":"golang的struct比较","uri":"/comparearrayandslice/"},{"categories":["golang"],"content":"相同类型 必须是相同类型的struct type A struct { Num int } type B struct { Num int } a := A{} b := B{} fmt.Println(a==b) 不同类型的struct比较的话会编译不通过：invalid operation: a == b (mismatched types A and B) ","date":"2021-01-13","objectID":"/comparearrayandslice/:1:0","tags":["golang","struct"],"title":"golang的struct比较","uri":"/comparearrayandslice/"},{"categories":["golang"],"content":"不可比较的类型 当strct里有一下3种类型时，则不可比较 map func slice type A struct { M map[int]int } a := A{} b := A{} fmt.Println(a==b) 以上代码编译时会报错：invalid operation: a == b (struct containing map[int]int cannot be compared) 可以到源码里找到相应的代码 /cmd/compile/internal/gc/typecheck.go func typecheck1() // 检查类型 func IncomparableField() // 返回结构体不可比较的字段，如果有的话 func IsComparable() // 判断字段的类型是否可以比较 func algtype1() // 判断类型是否可比较 ... // 类型不可比较时返回 // 每个类型都有一个flags属性，该属性包含了Noalg判断是否可以比较 // slice在初始化的时候会SetNoalg(true) // map在创建hmap时会SetNoalg(true) // func在创建匿名函数也会SetNoalg(true) if t.Noalg() { return ANOEQ, t } // 以防万一下面还会有一次判断 switch t.Etype { // func和map case TFUNC, TMAP: return ANOEQ, t // slice case TSLICE: return ANOEQ, t } 同理我们平时比较的时候，也不能用以上3种去比较 另外，若struct包含array或struct，那么array和struct也不能有以上3种类型 ","date":"2021-01-13","objectID":"/comparearrayandslice/:2:0","tags":["golang","struct"],"title":"golang的struct比较","uri":"/comparearrayandslice/"},{"categories":null,"content":"Hello World This is my first post. ","date":"2020-12-31","objectID":"/first/:0:0","tags":null,"title":"Hello World","uri":"/first/"}]